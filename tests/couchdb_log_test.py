#! /usr/bin/env python3
import sys
import time

import docker
import json
import unittest
import uuid
from http import HTTPStatus

from couchdb_docker_apis.couchdb_docker_api import run_couchdb_docker_container
from couchdb_rest_apis.couchdb_rest_api import create_db, delete_db, create_named_document, get_named_document, \
    delete_named_document
from json import JSONDecodeError

from tests.appg_env import current_path

__author__ = "Reinaldo Penno"
__copyright__ = "Copyright(c) 2018, Cisco Systems, Inc."
__license__ = "Proprietary"
__version__ = "0.1"
__email__ = "rapenno@gmail.com"


class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return json.JSONEncoder.encode(self, obj)


class SetDecoder(json.JSONDecoder):

    def __init__(self):
        json.JSONDecoder.__init__(self, object_hook=self.dict_to_object)

    def dict_to_object(self, d):
        for key, value in d.items():
            if isinstance(value, list):
                d[key] = set(value)
        return d


class RedisLogTest(unittest.TestCase):
    """Redis Log Entries Test Suite"""

    db_name = None
    couch_url = None
    doc_name = None
    couch_container = None
    docker_client = client = docker.from_env()

    @classmethod
    def setUpClass(cls):
        cls.couch_container = run_couchdb_docker_container(cls.docker_client)
        cls.db_name = "couchdb_unit_test"
        cls.couch_url = 'http://localhost:5984/'
        cls.doc_name = "network_map"
        if create_db(cls.couch_url, cls.db_name, overwrite=True):
            sys.exit(1)

    @classmethod
    def tearDownClass(cls):
        if delete_db(cls.couch_url, cls.db_name):
            sys.exit(1)
        if cls.couch_container is not None:
            cls.couch_container.stop()

    def setUp(self):
        pass

    def test_Bulk_Process(self):
        """
        We test that we can parse redis logs as generated by Appg core. Logs in
        redis are json strings and not json objects, therefore we need a double
        json.loads()
        :return:
        """
        with open(current_path + "/log_entries.txt") as fp:
            log_line = fp.readline()
            while log_line:
                try:
                    log_json = json.loads(log_line)
                    if isinstance(log_json, str):
                        json_dict = json.loads(log_json)
                        self.assertTrue(isinstance(json_dict, dict))
                    else:
                        self.assertTrue(False)
                    log_line = fp.readline()
                except JSONDecodeError:
                    self.assertTrue(False)

    def test_build_network_map(self):
        """
        We test that we can parse redis logs and create a network map
        that consists of ip -> (dest1, dest2, ...)
        :return:
        """
        nw_map = dict()
        nw_map["graph"] = dict()
        nw_map["graph"]["verified"] = dict()
        nw_map["graph"]["unverified"] = dict()
        nw_map["graph"]["threats"] = dict()
        with open(current_path + "/log_entries.txt") as fp:
            log_line = fp.readline()
            while log_line:
                try:
                    log_json = json.loads(log_line)
                    if isinstance(log_json, str):
                        json_dict = json.loads(log_json)
                        self.assertTrue(isinstance(json_dict, dict))
                        if "source" and "destination" in json_dict:
                            try:
                                nw_map["graph"]["verified"][json_dict["source"]].add(json_dict["destination"])
                            except KeyError:
                                nw_map["graph"]["verified"][json_dict["source"]] = {json_dict["destination"]}
                    else:
                        self.assertTrue(False)
                    log_line = fp.readline()
                except JSONDecodeError:
                    self.assertTrue(False)
            ret = create_named_document(type(self).couch_url, type(self).db_name, type(self).doc_name,
                                        json.dumps(nw_map, cls=SetEncoder))
            self.assertIsInstance(ret, dict)
            ret = delete_named_document(type(self).couch_url, type(self).db_name, type(self).doc_name)
            self.assertIsInstance(ret, dict)


    def test_build_network_map_and_overwrite(self):
        """
        We test that we can parse redis logs, create a network map and overwrite it
        :return:
        """
        nw_map = dict()
        nw_map["graph"] = dict()
        nw_map["graph"]["verified"] = dict()
        nw_map["graph"]["unverified"] = dict()
        nw_map["graph"]["threats"] = dict()
        with open(current_path + "/log_entries.txt") as fp:
            log_line = fp.readline()
            while log_line:
                try:
                    log_json = json.loads(log_line)
                    if isinstance(log_json, str):
                        json_dict = json.loads(log_json)
                        self.assertTrue(isinstance(json_dict, dict))
                        if "source" and "destination" in json_dict:
                            try:
                                nw_map["graph"]["verified"][json_dict["source"]].add(json_dict["destination"])
                            except KeyError:
                                nw_map["graph"]["verified"][json_dict["source"]] = {json_dict["destination"]}
                    else:
                        self.assertTrue(False)
                    log_line = fp.readline()
                except JSONDecodeError:
                    self.assertTrue(False)
            ret = create_named_document(type(self).couch_url, type(self).db_name, type(self).doc_name,
                                        json.dumps(nw_map, cls=SetEncoder))
            self.assertIsInstance(ret, dict)
            nw_map["graph"]["verified"] = dict()
            ret = create_named_document(type(self).couch_url, type(self).db_name, type(self).doc_name,
                                        json.dumps(nw_map, cls=SetEncoder), overwrite=True)
            self.assertIsInstance(ret, dict)
            json_dict = get_named_document(type(self).couch_url, type(self).db_name, type(self).doc_name)
            self.assertEqual(json_dict["graph"]["verified"], dict(), "Document overwrite failed")

    def test_build_mixed_network_map_v2(self):
        """
        We test that we can parse redis logs and create a network map
        that consists of ip -> (dest1, dest2, ...).

        These logs have source/app_name and destination/app_name
        :return:
        """
        nw_map = dict()
        nw_map["graph"] = dict()
        nw_map["graph"]["verified"] = dict()
        nw_map["graph"]["unverified"] = dict()
        nw_map["graph"]["threats"] = dict()
        with open(current_path + "/mixed_log_entries.txt") as fp:
            log_line = fp.readline()
            while log_line:
                try:
                    log_json = json.loads(log_line)
                    if isinstance(log_json, str):
                        json_dict = json.loads(log_json)
                        self.assertTrue(isinstance(json_dict, dict))
                        if "source" and "destination" in json_dict:
                            if json_dict["responseCode"] == HTTPStatus.FORBIDDEN:
                                try:
                                    nw_map["graph"]["threats"][json_dict["source"]].add(json_dict["destination"])
                                except KeyError:
                                    nw_map["graph"]["threats"][json_dict["source"]] = {json_dict["destination"]}
                            elif json_dict["source/app_name"] == json_dict["destination/app_name"] or \
                                    (json_dict["source/app_name"] == "unknown" and
                                     json_dict["destination/app_name"].split(".")[0] == "istio-ingress"):
                                try:
                                    nw_map["graph"]["verified"][json_dict["source"]].add(json_dict["destination"])
                                except KeyError:
                                    nw_map["graph"]["verified"][json_dict["source"]] = {json_dict["destination"]}

                            else:
                                try:
                                    nw_map["graph"]["unverified"][json_dict["source"]].add(json_dict["destination"])
                                except KeyError:
                                    nw_map["graph"]["unverified"][json_dict["source"]] = {json_dict["destination"]}
                            log_line = fp.readline()
                            continue
                    print("Malformed log: {}".format(log_json))
                    self.assertTrue(False)
                except JSONDecodeError:
                    self.assertTrue(False)
            nw_map["graph"]["uuid"] = str(uuid.uuid4())
            nw_map["graph"]["time"] = time.asctime(time.localtime())
            ret = create_named_document(type(self).couch_url, type(self).db_name, type(self).doc_name,
                                        json.dumps(nw_map, cls=SetEncoder))
            self.assertIsInstance(ret, dict)
            ret = delete_named_document(type(self).couch_url, type(self).db_name, type(self).doc_name)
            self.assertIsInstance(ret, dict)


    def test_set_encoder_decoder(self):
        """
        We test that we can parse redis logs and create a network map
        that consists of ip -> (dest1, dest2, ...).

        These logs have source/app_name and destination/app_name
        :return:
        """
        nw_map = dict()
        nw_map["graph"] = dict()
        nw_map["graph"]["verified"] = dict()
        nw_map["graph"]["unverified"] = dict()
        nw_map["graph"]["threats"] = dict()
        with open(current_path + "/mixed_log_entries.txt") as fp:
            log_line = fp.readline()
            while log_line:
                try:
                    log_json = json.loads(log_line)
                    if isinstance(log_json, str):
                        json_dict = json.loads(log_json)
                        self.assertTrue(isinstance(json_dict, dict))
                        if "source" and "destination" in json_dict:
                            if json_dict["responseCode"] == HTTPStatus.FORBIDDEN:
                                try:
                                    nw_map["graph"]["threats"][json_dict["source"]].add(json_dict["destination"])
                                except KeyError:
                                    nw_map["graph"]["threats"][json_dict["source"]] = {json_dict["destination"]}
                            elif json_dict["source/app_name"] == json_dict["destination/app_name"] or \
                                    (json_dict["source/app_name"] == "unknown" and
                                     json_dict["destination/app_name"].split(".")[0] == "istio-ingress"):
                                try:
                                    nw_map["graph"]["verified"][json_dict["source"]].add(json_dict["destination"])
                                except KeyError:
                                    nw_map["graph"]["verified"][json_dict["source"]] = {json_dict["destination"]}

                            else:
                                try:
                                    nw_map["graph"]["unverified"][json_dict["source"]].add(json_dict["destination"])
                                except KeyError:
                                    nw_map["graph"]["unverified"][json_dict["source"]] = {json_dict["destination"]}
                            log_line = fp.readline()
                            continue
                    print("Malformed log: {}".format(log_json))
                    self.assertTrue(False)
                except JSONDecodeError:
                    self.assertTrue(False)
            nw_map["graph"]["uuid"] = str(uuid.uuid4())
            nw_map["graph"]["time"] = time.asctime(time.localtime())
            nw_map_json = json.dumps(nw_map, cls=SetEncoder)
            nw_map_decoded = json.loads(nw_map_json, cls=SetDecoder)
            print(nw_map_decoded)
